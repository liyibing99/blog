(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{340:function(s,a,n){"use strict";n.r(a);var t=n(4),e=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"垂直居中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垂直居中"}},[s._v("#")]),s._v(" 垂直居中")]),s._v(" "),a("p",[s._v("在 CSS 中对元素进行水平居中是非常简单的：如果它是一个行内元素， 就对它的父元素应用 text-align: center；如果它是一个块级元素，就对\n它自身应用 margin: auto。然而如果要对一个元素进行垂直居中，处理起来就相对麻烦一点。")]),s._v(" "),a("h2",{attrs:{id:"_1-基于绝对定位的解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于绝对定位的解决方案"}},[s._v("#")]),s._v(" 1.基于绝对定位的解决方案")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("main {     \n  position: absolute; \n  top: 50%;   \n  left: 50%; \n  transform: translate(-50%, -50%); \n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("当我们在 translate() 变形函数中使用百分比值时，是以这个元素自身的宽度和高度 为基准进行换算和移动的，而这正是我们所需要的。接下来，只要换用基于\n百分比的 CSS 变形来对元素进行偏移，就不需要在偏移量中把元素的尺寸 写死了 上面得方案也需要注意得点")]),s._v(" "),a("ul",[a("li",[s._v("我们有时不能选用绝对定位，因为它对整个布局的影响太过强烈")]),s._v(" "),a("li",[s._v("如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视 口裁切掉")]),s._v(" "),a("li",[s._v("在某些浏览器中，这个方法可能会导致元素的显示有一些模糊，因 为元素可能被放置在半个像素上。这个问题可以用 transformstyle:\npreserve-3d 来修复，不过这个修复手段也可以认为是一个 hack，而且很难保证它在未来不会出问题")])]),s._v(" "),a("h2",{attrs:{id:"_2-基于视口单位的解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于视口单位的解决方案"}},[s._v("#")]),s._v(" 2.基于视口单位的解决方案")]),s._v(" "),a("p",[s._v("假设我们不想使用绝对定位，仍然可以采用 translate() 技巧来把这 个元素以其自身宽高的一半为距离进行移动；但是在缺少 left 和\ntop 的情 况下，如何把这个元素的左上角放置在容器的正中心呢？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("main {     \n  width: 18em;   \n  padding: 1em 1.5em;   \n  margin: 50vh auto 0;  \n  transform: translateY(-50%);\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("当然，这个技巧的实用性是 相当有限的，因为它只适用于在视口中居中的场景")]),s._v(" "),a("h2",{attrs:{id:"_3-基于-flexbox-的解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-基于-flexbox-的解决方案"}},[s._v("#")]),s._v(" 3.基于 Flexbox 的解决方案")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("main {     \n  display: flex;     \n  align-items: center;    \n  justify-content: center;     \n  width: 18em;     \n  height: 10em;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("这是毋庸置疑的最佳解决方案，因为 Flexbox（伸缩盒）是专门针对这类需求所设计的。我们之所以要讨论其他方\n案，仅仅是因为那些方案在浏览器的支持程度上稍微好一些而已。其实目前 现代浏览器对 Flexbox 的支持度已经相当不错了。")])])}),[],!1,null,null,null);a.default=e.exports}}]);