# 前端安全防护实践

随着 Web 应用的普及，前端安全问题日益突出。前端作为用户与系统交互的第一道防线，其安全性至关重要。本文将全面介绍前端安全威胁和防护措施，帮助开发者构建更安全的应用。

## 常见前端安全威胁

### 1. 跨站脚本攻击（XSS）

#### 存储型 XSS

攻击者将恶意脚本存储在服务器数据库中，当其他用户访问时执行。

```javascript
// 危险：直接渲染用户输入
function renderComment(comment) {
  return `<div>${comment.text}</div>`
}

// 安全：使用 DOMPurify 清理
import DOMPurify from 'dompurify'

function renderComment(comment) {
  return `<div>${DOMPurify.sanitize(comment.text)}</div>`
}
```

#### 反射型 XSS

恶意脚本通过 URL 参数传递，服务器反射回浏览器执行。

```javascript
// 危险：直接使用 URL 参数
const query = new URLSearchParams(window.location.search)
const name = query.get('name')
document.getElementById('welcome').innerHTML = `Welcome, ${name}`

// 安全：对输入进行编码
function encodeHTML(str) {
  return str.replace(/[&<>'"]/g, tag => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    "'": '&#39;',
    '"': '&quot;'
  }[tag]))
}

const safeName = encodeHTML(name)
document.getElementById('welcome').innerHTML = `Welcome, ${safeName}`
```

#### DOM 型 XSS

恶意脚本通过操作 DOM 直接执行。

```javascript
// 危险：使用 innerHTML
element.innerHTML = userInput

// 安全：使用 textContent
element.textContent = userInput

// 或者使用 createElement
const span = document.createElement('span')
span.textContent = userInput
element.appendChild(span)
```

### 2. 跨站请求伪造（CSRF）

攻击者诱导用户在已认证的网站上执行非预期操作。

```javascript
// 危险：没有 CSRF 保护
fetch('/api/transfer', {
  method: 'POST',
  body: JSON.stringify({ to: 'attacker', amount: 1000 }),
  credentials: 'include'
})

// 安全：使用 CSRF Token
async function transferMoney(to, amount) {
  const csrfToken = getCSRFToken()
  const response = await fetch('/api/transfer', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken
    },
    body: JSON.stringify({ to, amount }),
    credentials: 'include'
  })
  return response.json()
}

function getCSRFToken() {
  return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
}
```

### 3. 内容安全策略（CSP）

CSP 是一个额外的安全层，用于检测和缓解某些类型的攻击。

```javascript
// 设置 CSP 头
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline' https://trusted.cdn.com; " +
    "style-src 'self' 'unsafe-inline' https://trusted.cdn.com; " +
    "img-src 'self' data: https:; " +
    "connect-src 'self' https://api.example.com; " +
    "font-src 'self' https://trusted.cdn.com; " +
    "object-src 'none'; " +
    "base-uri 'self'; " +
    "form-action 'self'; " +
    "frame-ancestors 'none'; " +
    "upgrade-insecure-requests;"
  )
  next()
})

// 或者使用 meta 标签
// <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'">
```

### 4. 点击劫持

攻击者通过透明 iframe 诱导用户点击非预期目标。

```javascript
// 设置 X-Frame-Options 头
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY')
  next()
})

// 或者使用 CSP 的 frame-ancestors
res.setHeader('Content-Security-Policy', "frame-ancestors 'none'")
```

### 5. 敏感数据泄露

#### 不安全的存储

```javascript
// 危险：在 localStorage 存储敏感信息
localStorage.setItem('token', 'sensitive-token')
localStorage.setItem('user', JSON.stringify({ password: 'secret' }))

// 安全：使用 httpOnly Cookie
document.cookie = `token=sensitive-token; path=/; secure; httpOnly; SameSite=Strict`
```

#### 不安全的传输

```javascript
// 危险：使用 HTTP
fetch('http://api.example.com/data')

// 安全：使用 HTTPS
fetch('https://api.example.com/data')

// 强制 HTTPS
if (location.protocol !== 'https:') {
  location.replace(`https:${location.href.substring(location.protocol.length)}`)
}
```

## 安全防护措施

### 1. 输入验证和输出编码

#### 输入验证

```javascript
// 验证邮箱
function validateEmail(email) {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return re.test(email)
}

// 验证 URL
function validateURL(url) {
  try {
    new URL(url)
    return true
  } catch {
    return false
  }
}

// 验证数字范围
function validateRange(value, min, max) {
  const num = Number(value)
  return !isNaN(num) && num >= min && num <= max
}

// 使用 Zod 进行验证
import { z } from 'zod'

const userSchema = z.object({
  email: z.string().email(),
  age: z.number().min(0).max(120),
  name: z.string().min(2).max(50)
})

function validateUser(data) {
  return userSchema.parse(data)
}
```

#### 输出编码

```javascript
// HTML 编码
function encodeHTML(str) {
  const div = document.createElement('div')
  div.textContent = str
  return div.innerHTML
}

// URL 编码
function encodeURL(str) {
  return encodeURIComponent(str)
}

// JavaScript 编码
function encodeJS(str) {
  return str.replace(/['"\\]/g, '\\$&')
}

// CSS 编码
function encodeCSS(str) {
  return str.replace(/[<>"'&\\]/g, '\\$&')
}
```

### 2. 使用安全库

#### DOMPurify

```javascript
import DOMPurify from 'dompurify'

// 清理 HTML
const cleanHTML = DOMPurify.sanitize(dirtyHTML, {
  ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
  ALLOWED_ATTR: ['class']
})

// 配置
DOMPurify.addHook('uponSanitizeAttribute', function (node, data) {
  if (data.attrName === 'href') {
    if (!data.attrValue.startsWith('https://')) {
      node.removeAttribute('href')
    }
  }
})
```

#### Helmet

```javascript
import helmet from 'helmet'

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https://trusted.cdn.com"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://trusted.cdn.com"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.example.com"],
      fontSrc: ["'self'", "https://trusted.cdn.com"],
      objectSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
      frameAncestors: ["'none'"],
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
  xssFilter: true
}))
```

### 3. 认证和授权

#### JWT Token

```javascript
// 生成 Token
const jwt = require('jsonwebtoken')

function generateToken(user) {
  return jwt.sign(
    { userId: user.id, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: '1h' }
  )
}

// 验证 Token
function verifyToken(token) {
  try {
    return jwt.verify(token, process.env.JWT_SECRET)
  } catch (error) {
    throw new Error('Invalid token')
  }
}

// 使用 Token
async function authenticate(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1]
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' })
  }

  try {
    const decoded = verifyToken(token)
    req.user = decoded
    next()
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' })
  }
}
```

#### OAuth 2.0

```javascript
import { OAuth2Client } from 'google-auth-library'

const client = new OAuth2Client(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI
)

async function googleAuth(code) {
  const { tokens } = await client.getToken(code)
  const ticket = await client.verifyIdToken({
    idToken: tokens.id_token,
    audience: process.env.GOOGLE_CLIENT_ID
  })
  const payload = ticket.getPayload()
  return payload
}
```

### 4. 数据加密

#### 加密敏感数据

```javascript
import CryptoJS from 'crypto-js'

const SECRET_KEY = process.env.ENCRYPTION_KEY

function encrypt(text) {
  return CryptoJS.AES.encrypt(text, SECRET_KEY).toString()
}

function decrypt(ciphertext) {
  const bytes = CryptoJS.AES.decrypt(ciphertext, SECRET_KEY)
  return bytes.toString(CryptoJS.enc.Utf8)
}

// 使用
const encrypted = encrypt('sensitive data')
const decrypted = decrypt(encrypted)
```

#### 密码哈希

```javascript
import bcrypt from 'bcrypt'

async function hashPassword(password) {
  const salt = await bcrypt.genSalt(10)
  return bcrypt.hash(password, salt)
}

async function verifyPassword(password, hash) {
  return bcrypt.compare(password, hash)
}

// 使用
const hash = await hashPassword('user-password')
const isValid = await verifyPassword('user-password', hash)
```

### 5. 安全的 API 调用

#### 使用 HTTPS

```javascript
const API_BASE_URL = 'https://api.example.com'

async function fetchData(endpoint) {
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getToken()}`
    },
    credentials: 'include'
  })

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }

  return response.json()
}
```

#### 请求限流

```javascript
class RateLimiter {
  constructor(maxRequests, timeWindow) {
    this.maxRequests = maxRequests
    this.timeWindow = timeWindow
    this.requests = []
  }

  async makeRequest(requestFn) {
    const now = Date.now()
    this.requests = this.requests.filter(time => now - time < this.timeWindow)

    if (this.requests.length >= this.maxRequests) {
      throw new Error('Rate limit exceeded')
    }

    this.requests.push(now)
    return requestFn()
  }
}

const limiter = new RateLimiter(10, 60000) // 10 requests per minute

async function safeFetch(url) {
  return limiter.makeRequest(() => fetch(url))
}
```

### 6. 错误处理

#### 安全的错误处理

```javascript
// 不要暴露敏感信息
app.use((err, req, res, next) => {
  console.error(err)

  if (process.env.NODE_ENV === 'production') {
    res.status(500).json({ error: 'Internal server error' })
  } else {
    res.status(500).json({ error: err.message })
  }
})

// 前端错误处理
window.addEventListener('error', (event) => {
  console.error('Error:', event.error)
  // 发送到错误监控服务，但不暴露敏感信息
  sendToErrorMonitoring({
    message: event.error.message,
    stack: event.error.stack,
    url: window.location.href
  })
})
```

## 安全最佳实践

### 1. 依赖管理

```javascript
// 定期更新依赖
npm audit
npm audit fix

// 使用 npm-check-updates
npx npm-check-updates -u
npm install

// 锁定依赖版本
{
  "dependencies": {
    "react": "^18.2.0",
    "lodash": "4.17.21"
  }
}
```

### 2. 环境变量

```javascript
// 使用 .env 文件
// .env
API_BASE_URL=https://api.example.com
JWT_SECRET=your-secret-key
ENCRYPTION_KEY=your-encryption-key

// 使用 dotenv
import dotenv from 'dotenv'
dotenv.config()

const API_BASE_URL = process.env.API_BASE_URL
const JWT_SECRET = process.env.JWT_SECRET

// 不要在前端代码中暴露敏感信息
// 危险
const apiKey = 'your-api-key'

// 安全
const apiKey = process.env.API_KEY
```

### 3. 安全的日志记录

```javascript
// 不要记录敏感信息
function logUserAction(user, action) {
  console.log({
    userId: user.id,
    action: action.type,
    timestamp: new Date().toISOString()
    // 不要记录密码、token 等敏感信息
  })
}

// 使用安全的日志库
import winston from 'winston'

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
})
```

### 4. 安全的文件上传

```javascript
import multer from 'multer'
import path from 'path'

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/')
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9)
    cb(null, uniqueSuffix + path.extname(file.originalname))
  }
})

const upload = multer({
  storage,
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['.jpg', '.jpeg', '.png', '.gif']
    const ext = path.extname(file.originalname).toLowerCase()
    if (allowedTypes.includes(ext)) {
      cb(null, true)
    } else {
      cb(new Error('Invalid file type'))
    }
  },
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  }
})

app.post('/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' })
  }
  res.json({ filename: req.file.filename })
})
```

## 安全测试

### 1. 自动化安全测试

```javascript
// 使用 OWASP ZAP
const zaproxy = require('zaproxy')

async function securityScan(url) {
  const z = new zaproxy({
    apiKey: process.env.ZAP_API_KEY,
    proxy: 'http://localhost:8080'
  })

  await z.spider.scan(url)
  await z.ascan.scan(url)

  const alerts = await z.core.alerts(url)
  return alerts
}
```

### 2. 依赖漏洞扫描

```bash
# 使用 npm audit
npm audit

# 使用 Snyk
npx snyk test

# 使用 Dependabot
# 配置 .github/dependabot.yml
```

### 3. 代码安全检查

```javascript
// 使用 ESLint 安全规则
{
  "extends": [
    "plugin:security/recommended"
  ]
}

// 使用 SonarQube
// 配置 sonar-project.properties
```

## 安全检查清单

### 输入验证

- [ ] 验证所有用户输入
- [ ] 对输出进行编码
- [ ] 使用白名单验证
- [ ] 限制输入长度

### 输出编码

- [ ] HTML 编码
- [ ] URL 编码
- [ ] JavaScript 编码
- [ ] CSS 编码

### 认证和授权

- [ ] 使用强密码策略
- [ ] 实现 MFA
- [ ] 使用 HTTPS
- [ ] 实现 CSRF 保护
- [ ] 使用 JWT 或 Session

### 数据保护

- [ ] 加密敏感数据
- [ ] 使用 httpOnly Cookie
- [ ] 设置 SameSite 属性
- [ ] 不在前端存储敏感信息

### 安全头

- [ ] Content-Security-Policy
- [ ] X-Frame-Options
- [ ] X-Content-Type-Options
- [ ] Strict-Transport-Security
- [ ] X-XSS-Protection

### 依赖管理

- [ ] 定期更新依赖
- [ ] 扫描依赖漏洞
- [ ] 使用可信的依赖源
- [ ] 锁定依赖版本

### 监控和日志

- [ ] 监控安全事件
- [ ] 记录安全日志
- [ ] 设置安全告警
- [ ] 定期安全审计

## 总结

前端安全是一个持续的过程，需要：

1. **防御深度**：多层防护，不依赖单一安全措施
2. **最小权限原则**：只授予必要的权限
3. **持续监控**：实时监控安全事件
4. **定期审计**：定期进行安全审计和测试
5. **团队培训**：提高团队安全意识

通过实施这些安全措施，可以大大提高应用的安全性，保护用户数据和隐私。记住，安全不是一次性的工作，而是一个持续改进的过程。