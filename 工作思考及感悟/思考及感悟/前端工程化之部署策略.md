# 前端工程化之部署策略

部署策略是前端工程化的最后一步，也是确保应用稳定运行的关键环节。本文将全面介绍前端部署的各种策略和最佳实践。

## 部署概述

### 部署的重要性

1. **保证可用性**：确保应用能够稳定、可靠地运行
2. **提升性能**：通过合理的部署策略提高应用性能
3. **降低风险**：减少部署过程中的风险和故障
4. **提高效率**：自动化部署流程，提高发布效率

### 部署目标

- 高可用性
- 快速部署
- 零停机更新
- 易于回滚
- 成本效益

## 部署环境

### 1. 开发环境

```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - API_BASE_URL=http://localhost:5000/api
```

### 2. 测试环境

```yaml
# docker-compose.test.yml
version: '3.8'
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      - NODE_ENV=test
      - API_BASE_URL=https://test-api.example.com
```

### 3. 生产环境

```yaml
# docker-compose.prod.yml
version: '3.8'
services:
  web:
    image: my-app:latest
    ports:
      - "80:80"
      - "443:443"
    environment:
      - NODE_ENV=production
      - API_BASE_URL=https://api.example.com
    restart: always
```

## 容器化部署

### 1. Docker 配置

#### Dockerfile

```dockerfile
# 多阶段构建
FROM node:18-alpine AS builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

# 生产镜像
FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

#### Dockerfile.dev

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "run", "dev"]
```

### 2. Nginx 配置

```nginx
# nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    keepalive_timeout 65;
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript 
               application/x-javascript application/xml+rss 
               application/javascript application/json;

    server {
        listen 80;
        server_name localhost;

        root /usr/share/nginx/html;
        index index.html;

        location / {
            try_files $uri $uri/ /index.html;
        }

        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        location /api/ {
            proxy_pass http://backend:5000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

## CI/CD 部署

### 1. GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build
        run: npm run build

      - name: Build Docker image
        run: |
          docker build -t my-app:${{ github.sha }} .
          docker tag my-app:${{ github.sha }} my-app:latest

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push to Docker Hub
        run: |
          docker push my-app:${{ github.sha }}
          docker push my-app:latest

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            docker pull my-app:latest
            docker stop my-app || true
            docker rm my-app || true
            docker run -d --name my-app -p 80:80 my-app:latest
```

### 2. GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_IMAGE: my-app

build:
  stage: build
  image: node:18
  script:
    - npm ci
    - npm run build
  artifacts:
    paths:
      - dist/

test:
  stage: test
  image: node:18
  script:
    - npm ci
    - npm test

deploy:
  stage: deploy
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t $DOCKER_IMAGE:$CI_COMMIT_SHA .
    - docker tag $DOCKER_IMAGE:$CI_COMMIT_SHA $DOCKER_IMAGE:latest
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker push $DOCKER_IMAGE:$CI_COMMIT_SHA
    - docker push $DOCKER_IMAGE:latest
  only:
    - main
```

### 3. Jenkins Pipeline

```groovy
// Jenkinsfile
pipeline {
    agent any

    environment {
        DOCKER_IMAGE = 'my-app'
        DOCKER_TAG = "${env.BUILD_ID}"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install') {
            steps {
                sh 'npm ci'
            }
        }

        stage('Test') {
            steps {
                sh 'npm test'
            }
        }

        stage('Build') {
            steps {
                sh 'npm run build'
            }
        }

        stage('Docker Build') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} ."
                sh "docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest"
            }
        }

        stage('Docker Push') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'docker-hub',
                    usernameVariable: 'DOCKER_USER',
                    passwordVariable: 'DOCKER_PASS'
                )]) {
                    sh "docker login -u ${DOCKER_USER} -p ${DOCKER_PASS}"
                    sh "docker push ${DOCKER_IMAGE}:${DOCKER_TAG}"
                    sh "docker push ${DOCKER_IMAGE}:latest"
                }
            }
        }

        stage('Deploy') {
            steps {
                sh 'kubectl set image deployment/my-app my-app=${DOCKER_IMAGE}:${DOCKER_TAG}'
            }
        }
    }

    post {
        success {
            echo 'Deployment successful!'
        }
        failure {
            echo 'Deployment failed!'
        }
    }
}
```

## 云平台部署

### 1. AWS 部署

#### S3 + CloudFront

```bash
# 部署到 S3
aws s3 sync ./dist s3://my-bucket --delete

# 配置 CloudFront
aws cloudfront create-distribution \
  --distribution-config '{
    "CallerReference": "my-distribution",
    "Comment": "My App Distribution",
    "DefaultRootObject": "index.html",
    "Origins": {
      "Items": [
        {
          "Id": "S3Origin",
          "DomainName": "my-bucket.s3.amazonaws.com",
          "S3OriginConfig": {}
        }
      ],
      "Quantity": 1
    },
    "DefaultCacheBehavior": {
      "TargetOriginId": "S3Origin",
      "ViewerProtocolPolicy": "redirect-to-https",
      "AllowedMethods": {
        "Quantity": 2,
        "Items": ["GET", "HEAD"]
      },
      "ForwardedValues": {
        "QueryString": false,
        "Cookies": {
          "Forward": "none"
        }
      }
    },
    "Enabled": true
  }'
```

#### EC2 部署

```bash
# 创建 EC2 实例
aws ec2 run-instances \
  --image-id ami-0abcdef1234567890 \
  --count 1 \
  --instance-type t2.micro \
  --key-name my-key-pair \
  --security-group-ids sg-903004f8 \
  --user-data file://user-data.sh
```

```bash
# user-data.sh
#!/bin/bash
yum update -y
yum install -y docker
service docker start
usermod -aG docker ec2-user

docker pull my-app:latest
docker run -d -p 80:80 my-app:latest
```

### 2. 阿里云部署

#### OSS + CDN

```bash
# 上传到 OSS
ossutil cp -r ./dist oss://my-bucket/

# 配置 CDN
aliyun cdn AddCdnDomain \
  --DomainName my-app.example.com \
  --CdnType web \
  --SceneType video \
  --Sources.1.Type oss \
  --Sources.1.Content my-bucket.oss-cn-hangzhou.aliyuncs.com
```

#### ECS 部署

```bash
# 创建 ECS 实例
aliyun ecs CreateInstance \
  --RegionId cn-hangzhou \
  --ImageId ubuntu_18_04_64_20G_alibase_20190624.vhd \
  --InstanceType ecs.t6-c1m1.large \
  --SecurityGroupId sg-bp123456789 \
  --VSwitchId vsw-bp123456789
```

### 3. Vercel 部署

```json
// vercel.json
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist"
      }
    }
  ],
  "routes": [
    {
      "src": "/(.*)",
      "dest": "/index.html"
    }
  ],
  "env": {
    "API_BASE_URL": "@api-base-url"
  }
}
```

## Kubernetes 部署

### 1. Deployment

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: my-app:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
```

### 2. Service

```yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
```

### 3. Ingress

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - my-app.example.com
    secretName: my-app-tls
  rules:
  - host: my-app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: my-app-service
            port:
              number: 80
```

### 4. ConfigMap

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-app-config
data:
  API_BASE_URL: "https://api.example.com"
  CDN_URL: "https://cdn.example.com"
```

### 5. Secret

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-app-secret
type: Opaque
stringData:
  API_KEY: "your-api-key"
  JWT_SECRET: "your-jwt-secret"
```

## 蓝绿部署

### 1. 策略说明

蓝绿部署是一种零停机部署策略，通过维护两个相同的生产环境（蓝色和绿色），在新版本部署完成后切换流量。

### 2. 实现方案

```yaml
# blue-green-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
      version: blue
  template:
    metadata:
      labels:
        app: my-app
        version: blue
    spec:
      containers:
      - name: my-app
        image: my-app:v1.0
        ports:
        - containerPort: 80
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
      version: green
  template:
    metadata:
      labels:
        app: my-app
        version: green
    spec:
      containers:
      - name: my-app
        image: my-app:v2.0
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
    version: blue
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
```

```bash
# 切换流量到绿色环境
kubectl patch service my-app-service -p '{"spec":{"selector":{"version":"green"}}}'
```

## 金丝雀发布

### 1. 策略说明

金丝雀发布是一种渐进式发布策略，先向小部分用户发布新版本，验证无误后再逐步扩大范围。

### 2. 实现方案

```yaml
# canary-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-stable
spec:
  replicas: 9
  selector:
    matchLabels:
      app: my-app
      track: stable
  template:
    metadata:
      labels:
        app: my-app
        track: stable
    spec:
      containers:
      - name: my-app
        image: my-app:v1.0
        ports:
        - containerPort: 80
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-canary
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
      track: canary
  template:
    metadata:
      labels:
        app: my-app
        track: canary
    spec:
      containers:
      - name: my-app
        image: my-app:v2.0
        ports:
        - containerPort: 80
```

```bash
# 逐步增加金丝雀版本副本数
kubectl scale deployment my-app-canary --replicas=2
kubectl scale deployment my-app-stable --replicas=8

# 完全切换到新版本
kubectl scale deployment my-app-canary --replicas=10
kubectl scale deployment my-app-stable --replicas=0
```

## 监控和日志

### 1. 监控配置

```yaml
# prometheus.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
      - job_name: 'my-app'
        static_configs:
          - targets: ['my-app-service:80']
```

### 2. 日志收集

```yaml
# fluentd-daemonset.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
spec:
  selector:
    matchLabels:
      name: fluentd
  template:
    metadata:
      labels:
        name: fluentd
    spec:
      containers:
      - name: fluentd
        image: fluent/fluentd-kubernetes-daemonset:v1-debian-elasticsearch
        env:
        - name: FLUENT_ELASTICSEARCH_HOST
          value: "elasticsearch.logging"
        - name: FLUENT_ELASTICSEARCH_PORT
          value: "9200"
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
```

## 回滚策略

### 1. 快速回滚

```bash
# Kubernetes 回滚
kubectl rollout undo deployment/my-app

# 回滚到指定版本
kubectl rollout undo deployment/my-app --to-revision=2
```

### 2. 蓝绿回滚

```bash
# 切换回蓝色环境
kubectl patch service my-app-service -p '{"spec":{"selector":{"version":"blue"}}}'
```

### 3. Docker 回滚

```bash
# 回滚到上一个版本
docker stop my-app
docker rm my-app
docker run -d --name my-app -p 80:80 my-app:previous-version
```

## 最佳实践

### 1. 环境隔离

```bash
# 为不同环境使用不同的配置
# .env.development
API_BASE_URL=http://localhost:5000/api

# .env.production
API_BASE_URL=https://api.example.com
```

### 2. 健康检查

```javascript
// health-check.js
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  })
})
```

### 3. 优雅关闭

```javascript
// graceful-shutdown.js
const server = app.listen(port, () => {
  console.log(`Server running on port ${port}`)
})

process.on('SIGTERM', () => {
  console.log('SIGTERM signal received: closing HTTP server')
  server.close(() => {
    console.log('HTTP server closed')
  })
})
```

### 4. 错误处理

```javascript
// error-handling.js
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  })
})
```

## 总结

部署策略是前端工程化的重要组成部分，需要：

1. **选择合适的部署方式**：根据项目需求选择容器化、云平台或 K8s 部署
2. **实现自动化部署**：使用 CI/CD 工具实现自动化部署流程
3. **采用渐进式发布**：使用蓝绿部署或金丝雀发布降低风险
4. **完善监控和日志**：建立完善的监控和日志系统
5. **制定回滚策略**：确保出现问题时能够快速回滚
6. **持续优化**：根据实际情况持续优化部署流程

通过建立完善的部署策略，可以确保应用的稳定运行和快速迭代。记住，部署不是一次性的事情，而是一个持续优化的过程。