# 前端测试策略与实践

前端测试是保证代码质量、提高开发效率的重要手段。良好的测试策略能够帮助开发者及时发现和修复问题，提高代码的可维护性和稳定性。本文将全面介绍前端测试的策略和实践方法。

## 测试类型

### 1. 单元测试

单元测试是对代码中最小可测试单元（通常是函数、组件）的测试。

#### Jest 基础

```javascript
// sum.js
export function sum(a, b) {
  return a + b
}

// sum.test.js
import { sum } from './sum'

describe('sum', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3)
  })

  test('handles negative numbers', () => {
    expect(sum(-1, -2)).toBe(-3)
  })

  test('handles zero', () => {
    expect(sum(0, 0)).toBe(0)
  })
})
```

#### React 组件测试

```javascript
// Button.jsx
import React from 'react'

function Button({ onClick, children, disabled }) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className="btn"
    >
      {children}
    </button>
  )
}

export default Button

// Button.test.jsx
import { render, screen, fireEvent } from '@testing-library/react'
import Button from './Button'

describe('Button', () => {
  test('renders button with text', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toBeInTheDocument()
  })

  test('calls onClick when clicked', () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    
    fireEvent.click(screen.getByText('Click me'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  test('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>)
    expect(screen.getByText('Click me')).toBeDisabled()
  })

  test('has correct class name', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toHaveClass('btn')
  })
})
```

#### Hooks 测试

```javascript
// useCounter.js
import { useState } from 'react'

export function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue)

  const increment = () => setCount(prev => prev + 1)
  const decrement = () => setCount(prev => prev - 1)
  const reset = () => setCount(initialValue)

  return { count, increment, decrement, reset }
}

// useCounter.test.js
import { renderHook, act } from '@testing-library/react-hooks'
import { useCounter } from './useCounter'

describe('useCounter', () => {
  test('initializes with default value', () => {
    const { result } = renderHook(() => useCounter())
    expect(result.current.count).toBe(0)
  })

  test('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10))
    expect(result.current.count).toBe(10)
  })

  test('increments count', () => {
    const { result } = renderHook(() => useCounter())
    
    act(() => {
      result.current.increment()
    })
    
    expect(result.current.count).toBe(1)
  })

  test('decrements count', () => {
    const { result } = renderHook(() => useCounter(10))
    
    act(() => {
      result.current.decrement()
    })
    
    expect(result.current.count).toBe(9)
  })

  test('resets count', () => {
    const { result } = renderHook(() => useCounter(10))
    
    act(() => {
      result.current.increment()
      result.current.increment()
      result.current.reset()
    })
    
    expect(result.current.count).toBe(10)
  })
})
```

### 2. 集成测试

集成测试测试多个组件或模块之间的交互。

```javascript
// Form.jsx
import React, { useState } from 'react'
import Button from './Button'

function Form({ onSubmit }) {
  const [name, setName] = useState('')
  const [email, setEmail] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault()
    onSubmit({ name, email })
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
        data-testid="name-input"
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        data-testid="email-input"
      />
      <Button type="submit">Submit</Button>
    </form>
  )
}

export default Form

// Form.test.jsx
import { render, screen, fireEvent } from '@testing-library/react'
import Form from './Form'

describe('Form', () => {
  test('submits form with data', () => {
    const handleSubmit = jest.fn()
    render(<Form onSubmit={handleSubmit} />)

    fireEvent.change(screen.getByTestId('name-input'), {
      target: { value: 'John Doe' }
    })
    fireEvent.change(screen.getByTestId('email-input'), {
      target: { value: 'john@example.com' }
    })
    fireEvent.click(screen.getByText('Submit'))

    expect(handleSubmit).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com'
    })
  })

  test('does not submit when fields are empty', () => {
    const handleSubmit = jest.fn()
    render(<Form onSubmit={handleSubmit} />)

    fireEvent.click(screen.getByText('Submit'))

    expect(handleSubmit).toHaveBeenCalledWith({
      name: '',
      email: ''
    })
  })
})
```

### 3. 端到端测试（E2E）

端到端测试模拟真实用户操作，测试整个应用流程。

#### Cypress 示例

```javascript
// cypress/e2e/login.cy.js
describe('Login Flow', () => {
  beforeEach(() => {
    cy.visit('/login')
  })

  it('should login with valid credentials', () => {
    cy.get('[data-testid="email-input"]').type('user@example.com')
    cy.get('[data-testid="password-input"]').type('password123')
    cy.get('[data-testid="login-button"]').click()

    cy.url().should('include', '/dashboard')
    cy.contains('Welcome, User').should('be.visible')
  })

  it('should show error with invalid credentials', () => {
    cy.get('[data-testid="email-input"]').type('invalid@example.com')
    cy.get('[data-testid="password-input"]').type('wrongpassword')
    cy.get('[data-testid="login-button"]').click()

    cy.contains('Invalid credentials').should('be.visible')
  })

  it('should validate email format', () => {
    cy.get('[data-testid="email-input"]').type('invalid-email')
    cy.get('[data-testid="password-input"]').type('password123')
    cy.get('[data-testid="login-button"]').click()

    cy.contains('Invalid email format').should('be.visible')
  })
})

// cypress/e2e/checkout.cy.js
describe('Checkout Flow', () => {
  beforeEach(() => {
    cy.login('user@example.com', 'password123')
    cy.visit('/cart')
  })

  it('should complete checkout process', () => {
    cy.get('[data-testid="checkout-button"]').click()
    
    cy.get('[data-testid="shipping-form"]').should('be.visible')
    cy.get('[data-testid="address-input"]').type('123 Main St')
    cy.get('[data-testid="city-input"]').type('New York')
    cy.get('[data-testid="zip-input"]').type('10001')
    
    cy.get('[data-testid="continue-button"]').click()
    
    cy.get('[data-testid="payment-form"]').should('be.visible')
    cy.get('[data-testid="card-number-input"]').type('4242424242424242')
    cy.get('[data-testid="card-expiry-input"]').type('12/25')
    cy.get('[data-testid="card-cvc-input"]').type('123')
    
    cy.get('[data-testid="place-order-button"]').click()
    
    cy.url().should('include', '/order-confirmation')
    cy.contains('Order placed successfully').should('be.visible')
  })
})
```

#### Playwright 示例

```javascript
// tests/login.spec.js
const { test, expect } = require('@playwright/test')

test.describe('Login Flow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login')
  })

  test('should login with valid credentials', async ({ page }) => {
    await page.fill('[data-testid="email-input"]', 'user@example.com')
    await page.fill('[data-testid="password-input"]', 'password123')
    await page.click('[data-testid="login-button"]')

    await expect(page).toHaveURL(/.*\/dashboard/)
    await expect(page.locator('text=Welcome, User')).toBeVisible()
  })

  test('should show error with invalid credentials', async ({ page }) => {
    await page.fill('[data-testid="email-input"]', 'invalid@example.com')
    await page.fill('[data-testid="password-input"]', 'wrongpassword')
    await page.click('[data-testid="login-button"]')

    await expect(page.locator('text=Invalid credentials')).toBeVisible()
  })
})
```

## 测试工具

### 1. Jest

#### 配置

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
    '!src/**/__tests__/**',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
}
```

#### Mock

```javascript
// mock API
import { fetchUser } from './api'

jest.mock('./api', () => ({
  fetchUser: jest.fn(),
}))

describe('UserComponent', () => {
  test('displays user data', async () => {
    const mockUser = { id: 1, name: 'John Doe' }
    fetchUser.mockResolvedValue(mockUser)

    render(<UserComponent userId={1} />)

    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument()
    })
  })
})

// mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
}
global.localStorage = localStorageMock
```

### 2. React Testing Library

#### 查询方法

```javascript
import { render, screen } from '@testing-library/react'

// 按文本查询
screen.getByText('Hello')
screen.queryByText('Hello')
screen.findAllByText('Hello')

// 按角色查询
screen.getByRole('button')
screen.getByRole('textbox')
screen.getByRole('heading', { name: 'Welcome' })

// 按测试 ID 查询
screen.getByTestId('submit-button')

// 按标签文本查询
screen.getByLabelText('Email')

// 按占位符查询
screen.getByPlaceholderText('Enter your name')
```

#### 用户交互

```javascript
import { fireEvent, userEvent } from '@testing-library/react'

// 使用 fireEvent
fireEvent.click(screen.getByText('Submit'))
fireEvent.change(screen.getByLabelText('Email'), {
  target: { value: 'test@example.com' }
})

// 使用 userEvent（更真实）
userEvent.click(screen.getByText('Submit'))
userEvent.type(screen.getByLabelText('Email'), 'test@example.com')
userEvent.tab()
userEvent.keyboard('{Enter}')
```

### 3. Vitest

#### 配置

```javascript
// vitest.config.js
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: './src/test/setup.js',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
      ],
    },
  },
})
```

## 测试最佳实践

### 1. 测试金字塔

```
        /\
       /E2E\      (少量)
      /------\
     /集成测试\    (适量)
    /----------\
   /  单元测试  \  (大量)
  /--------------\
```

### 2. 测试命名

```javascript
// 好的测试名称
describe('Button', () => {
  test('should be disabled when disabled prop is true', () => {})
  test('should call onClick when clicked', () => {})
  test('should render children', () => {})
})

// 不好的测试名称
describe('Button', () => {
  test('test 1', () => {})
  test('button test', () => {})
  test('it works', () => {})
})
```

### 3. AAA 模式

```javascript
test('should add item to cart', () => {
  // Arrange（准备）
  const addToCart = jest.fn()
  render(<CartButton onClick={addToCart} />)

  // Act（执行）
  fireEvent.click(screen.getByText('Add to Cart'))

  // Assert（断言）
  expect(addToCart).toHaveBeenCalledTimes(1)
})
```

### 4. 测试覆盖率

```javascript
// 设置覆盖率目标
// jest.config.js
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
}

// 运行覆盖率测试
npm test -- --coverage
```

### 5. 避免测试实现细节

```javascript
// 不好的测试：测试实现细节
test('should call setState with correct value', () => {
  const component = new MyComponent()
  component.handleButtonClick()
  expect(component.state.count).toBe(1)
})

// 好的测试：测试用户行为
test('should increment counter when button is clicked', () => {
  render(<Counter />)
  fireEvent.click(screen.getByText('Increment'))
  expect(screen.getByText('Count: 1')).toBeInTheDocument()
})
```

## 测试策略

### 1. 测试驱动开发（TDD）

```javascript
// 1. 先写测试
test('should calculate total price', () => {
  const items = [
    { price: 10, quantity: 2 },
    { price: 5, quantity: 1 },
  ]
  expect(calculateTotal(items)).toBe(25)
})

// 2. 运行测试（失败）
// 3. 实现功能
function calculateTotal(items) {
  return items.reduce((total, item) => {
    return total + item.price * item.quantity
  }, 0)
}

// 4. 运行测试（通过）
```

### 2. 行为驱动开发（BDD）

```javascript
// 使用 Gherkin 语法
describe('Shopping Cart', () => {
  describe('Adding items', () => {
    it('should add item to cart when user clicks add button', () => {
      // Given（给定）
      render(<ShoppingCart />)
      
      // When（当）
      fireEvent.click(screen.getByText('Add to Cart'))
      
      // Then（那么）
      expect(screen.getByText('Cart: 1')).toBeInTheDocument()
    })
  })
})
```

### 3. 测试隔离

```javascript
// 每个测试应该是独立的
beforeEach(() => {
  // 清理状态
  localStorage.clear()
  jest.clearAllMocks()
})

test('test 1', () => {
  // 不依赖其他测试的状态
})

test('test 2', () => {
  // 不依赖其他测试的状态
})
```

## 持续集成

### 1. GitHub Actions

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [16.x, 18.x]

    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linter
      run: npm run lint
    
    - name: Run tests
      run: npm test -- --coverage
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/coverage-final.json
```

### 2. GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - test

test:
  stage: test
  image: node:18
  cache:
    paths:
      - node_modules/
  script:
    - npm ci
    - npm run lint
    - npm test -- --coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
```

## 测试检查清单

### 单元测试

- [ ] 测试核心业务逻辑
- [ ] 测试边界条件
- [ ] 测试错误处理
- [ ] 测试异步操作
- [ ] 使用 Mock 隔离依赖

### 组件测试

- [ ] 测试用户交互
- [ ] 测试 props 变化
- [ ] 测试状态变化
- [ ] 测试条件渲染
- [ ] 测试可访问性

### 集成测试

- [ ] 测试组件间交互
- [ ] 测试 API 集成
- [ ] 测试路由导航
- [ ] 测试状态管理
- [ ] 测试表单提交

### E2E 测试

- [ ] 测试关键用户流程
- [ ] 测试跨浏览器兼容性
- [ ] 测试响应式设计
- [ ] 测试性能
- [ ] 测试错误场景

## 总结

前端测试是保证代码质量的重要手段，需要：

1. **选择合适的测试类型**：根据测试目标选择单元测试、集成测试或 E2E 测试
2. **遵循测试金字塔**：大部分测试应该是单元测试，少量 E2E 测试
3. **使用合适的工具**：选择适合项目需求的测试工具
4. **编写可维护的测试**：遵循最佳实践，编写清晰、可维护的测试
5. **集成到 CI/CD**：将测试集成到持续集成流程中
6. **持续改进**：定期审查和改进测试策略

通过建立完善的测试体系，可以大大提高代码质量，减少 bug，提高开发效率。记住，测试不是负担，而是投资，会在长期带来巨大的回报。