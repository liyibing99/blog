# 前端性能监控与优化

前端性能直接影响用户体验和业务指标。良好的性能监控和优化策略能够帮助开发者及时发现和解决性能问题，提升用户满意度。本文将全面介绍前端性能监控的方法和优化技巧。

## 性能指标

### 核心性能指标

#### 1. 加载性能

- **FCP (First Contentful Paint)**：首次内容绘制，用户看到第一个内容的时间
- **LCP (Largest Contentful Paint)**：最大内容绘制，主要内容加载完成的时间
- **FMP (First Meaningful Paint)**：首次有意义绘制，用户感知到页面有用的时间
- **TTI (Time to Interactive)**：可交互时间，页面完全可交互的时间

#### 2. 运行时性能

- **FID (First Input Delay)**：首次输入延迟，用户首次交互到页面响应的时间
- **TBT (Total Blocking Time)**：总阻塞时间，主线程被阻塞的总时间
- **CLS (Cumulative Layout Shift)**：累积布局偏移，页面布局稳定性指标

#### 3. 用户体验指标

- **FCP < 1.8s**：良好
- **LCP < 2.5s**：良好
- **FID < 100ms**：良好
- **TBT < 200ms**：良好
- **CLS < 0.1**：良好

## 性能监控

### 1. 浏览器性能 API

#### Performance API

```javascript
// 获取性能指标
const perfData = performance.getEntriesByType('navigation')[0]

console.log({
  DNS查询时间: perfData.domainLookupEnd - perfData.domainLookupStart,
  TCP连接时间: perfData.connectEnd - perfData.connectStart,
  请求响应时间: perfData.responseEnd - perfData.requestStart,
  DOM解析时间: perfData.domComplete - perfData.domInteractive,
  白屏时间: perfData.responseStart - perfData.navigationStart,
  首屏时间: perfData.domContentLoadedEventEnd - perfData.navigationStart,
  页面加载完成时间: perfData.loadEventEnd - perfData.navigationStart,
})

// 获取资源加载时间
const resources = performance.getEntriesByType('resource')
resources.forEach(resource => {
  console.log({
    name: resource.name,
    duration: resource.duration,
    size: resource.transferSize,
  })
})
```

#### Performance Observer API

```javascript
// 监控 LCP
const observerLCP = new PerformanceObserver((list) => {
  const entries = list.getEntries()
  const lastEntry = entries[entries.length - 1]
  console.log('LCP:', lastEntry.startTime)
})
observerLCP.observe({ type: 'largest-contentful-paint', buffered: true })

// 监控 FID
const observerFID = new PerformanceObserver((list) => {
  const entries = list.getEntries()
  const firstEntry = entries[0]
  console.log('FID:', firstEntry.processingStart - firstEntry.startTime)
})
observerFID.observe({ type: 'first-input', buffered: true })

// 监控 CLS
let clsValue = 0
const observerCLS = new PerformanceObserver((list) => {
  const entries = list.getEntries()
  entries.forEach((entry) => {
    if (!entry.hadRecentInput) {
      clsValue += entry.value
    }
  })
  console.log('CLS:', clsValue)
})
observerCLS.observe({ type: 'layout-shift', buffered: true })
```

### 2. Web Vitals 库

```javascript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals'

getCLS(console.log)
getFID(console.log)
getFCP(console.log)
getLCP(console.log)
getTTFB(console.log)
```

### 3. 自定义性能监控

```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = {}
    this.init()
  }

  init() {
    if ('PerformanceObserver' in window) {
      this.monitorLCP()
      this.monitorFID()
      this.monitorCLS()
      this.monitorFCP()
    }
  }

  monitorLCP() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const lastEntry = entries[entries.length - 1]
      this.metrics.lcp = lastEntry.startTime
      this.reportMetric('LCP', this.metrics.lcp)
    })
    observer.observe({ type: 'largest-contentful-paint', buffered: true })
  }

  monitorFID() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const firstEntry = entries[0]
      this.metrics.fid = firstEntry.processingStart - firstEntry.startTime
      this.reportMetric('FID', this.metrics.fid)
    })
    observer.observe({ type: 'first-input', buffered: true })
  }

  monitorCLS() {
    let clsValue = 0
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      entries.forEach((entry) => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value
        }
      })
      this.metrics.cls = clsValue
      this.reportMetric('CLS', clsValue)
    })
    observer.observe({ type: 'layout-shift', buffered: true })
  }

  monitorFCP() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const firstEntry = entries[0]
      this.metrics.fcp = firstEntry.startTime
      this.reportMetric('FCP', this.metrics.fcp)
    })
    observer.observe({ type: 'paint', buffered: true })
  }

  reportMetric(name, value) {
    console.log(`[Performance] ${name}: ${value.toFixed(2)}ms`)
    // 发送到监控服务
    this.sendToMonitoringService(name, value)
  }

  sendToMonitoringService(name, value) {
    // 发送到监控服务（如 Sentry、DataDog 等）
    fetch('/api/performance', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        metric: name,
        value,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent,
      }),
    })
  }
}

const monitor = new PerformanceMonitor()
```

### 4. 错误监控

```javascript
// 捕获 JavaScript 错误
window.addEventListener('error', (event) => {
  console.error('JavaScript Error:', event.error)
  // 发送到监控服务
})

// 捕获 Promise 错误
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled Promise Rejection:', event.reason)
  // 发送到监控服务
})

// 捕获资源加载错误
window.addEventListener('error', (event) => {
  if (event.target !== window) {
    console.error('Resource Error:', event.target.src || event.target.href)
    // 发送到监控服务
  }
}, true)
```

### 5. 用户行为监控

```javascript
class UserBehaviorMonitor {
  constructor() {
    this.events = []
    this.init()
  }

  init() {
    this.monitorClicks()
    this.monitorScrolls()
    this.monitorInputs()
    this.monitorNavigation()
  }

  monitorClicks() {
    document.addEventListener('click', (event) => {
      this.recordEvent('click', {
        target: event.target.tagName,
        x: event.clientX,
        y: event.clientY,
      })
    })
  }

  monitorScrolls() {
    let scrollTimeout
    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout)
      scrollTimeout = setTimeout(() => {
        this.recordEvent('scroll', {
          scrollY: window.scrollY,
          scrollPercentage: (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100,
        })
      }, 100)
    })
  }

  monitorInputs() {
    document.addEventListener('input', (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        this.recordEvent('input', {
          target: event.target.tagName,
          type: event.target.type,
        })
      }
    })
  }

  monitorNavigation() {
    window.addEventListener('popstate', () => {
      this.recordEvent('navigation', {
        url: window.location.href,
      })
    })
  }

  recordEvent(type, data) {
    const event = {
      type,
      data,
      timestamp: Date.now(),
      url: window.location.href,
    }
    this.events.push(event)
    console.log('[User Behavior]', event)
  }
}

const userMonitor = new UserBehaviorMonitor()
```

## 性能优化

### 1. 资源加载优化

#### 代码分割

```javascript
// 路由级别代码分割
const Home = lazy(() => import('./pages/Home'))
const About = lazy(() => import('./pages/About'))
const Contact = lazy(() => import('./pages/Contact'))

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </Suspense>
  )
}

// 组件级别代码分割
const HeavyComponent = lazy(() => import('./HeavyComponent'))

function ParentComponent() {
  const [showHeavy, setShowHeavy] = useState(false)

  return (
    <div>
      <button onClick={() => setShowHeavy(true)}>Load Heavy Component</button>
      {showHeavy && (
        <Suspense fallback={<Loading />}>
          <HeavyComponent />
        </Suspense>
      )}
    </div>
  )
}
```

#### 预加载和预连接

```html
<!-- DNS 预解析 -->
<link rel="dns-prefetch" href="https://api.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://cdn.example.com">

<!-- 预加载 -->
<link rel="preload" href="/styles/main.css" as="style">
<link rel="preload" href="/scripts/main.js" as="script">

<!-- 预获取 -->
<link rel="prefetch" href="/next-page.js">
```

#### 资源压缩

```javascript
// webpack 配置
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
            drop_debugger: true,
          },
        },
      }),
      new CssMinimizerPlugin(),
    ],
  },
}
```

### 2. 渲染优化

#### 虚拟滚动

```javascript
import { FixedSizeList } from 'react-window'

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  )

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  )
}
```

#### 防抖和节流

```javascript
// 防抖
function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 节流
function throttle(func, limit) {
  let inThrottle
  return function executedFunction(...args) {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// 使用
const handleSearch = debounce((query) => {
  fetch(`/api/search?q=${query}`)
}, 300)

const handleScroll = throttle(() => {
  console.log('Scrolling...')
}, 100)
```

#### 图片优化

```javascript
// 响应式图片
<picture>
  <source media="(max-width: 600px)" srcset="small.jpg">
  <source media="(max-width: 1200px)" srcset="medium.jpg">
  <img src="large.jpg" alt="Description" loading="lazy">
</picture>

// 懒加载
<img src="placeholder.jpg" data-src="actual.jpg" loading="lazy" alt="Description">

// WebP 格式
<picture>
  <source type="image/webp" srcset="image.webp">
  <img src="image.jpg" alt="Description">
</picture>
```

### 3. 缓存优化

#### Service Worker

```javascript
// 注册 Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        console.log('SW registered:', registration)
      })
      .catch(error => {
        console.log('SW registration failed:', error)
      })
  })
}

// sw.js
const CACHE_NAME = 'v1'
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
]

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  )
})

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  )
})
```

#### HTTP 缓存

```javascript
// 设置缓存头
app.use(express.static('public', {
  maxAge: '1y',
  etag: true,
  lastModified: true,
}))

// 版本控制
<script src="/scripts/main.js?v=1.2.3"></script>
<link rel="stylesheet" href="/styles/main.css?v=1.2.3">
```

### 4. 内存优化

#### 避免内存泄漏

```javascript
// 清理事件监听器
useEffect(() => {
  const handleResize = () => {
    console.log('Resize')
  }
  window.addEventListener('resize', handleResize)
  return () => {
    window.removeEventListener('resize', handleResize)
  }
}, [])

// 清理定时器
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Timer')
  }, 1000)
  return () => {
    clearInterval(timer)
  }
}, [])

// 清理订阅
useEffect(() => {
  const subscription = dataStream.subscribe(data => {
    console.log(data)
  })
  return () => {
    subscription.unsubscribe()
  }
}, [])
```

#### 对象池

```javascript
class ObjectPool {
  constructor(createFn, resetFn, initialSize = 10) {
    this.createFn = createFn
    this.resetFn = resetFn
    this.pool = []
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn())
    }
  }

  acquire() {
    return this.pool.length > 0
      ? this.pool.pop()
      : this.createFn()
  }

  release(obj) {
    this.resetFn(obj)
    this.pool.push(obj)
  }
}

// 使用
const pool = new ObjectPool(
  () => ({ data: null }),
  (obj) => { obj.data = null }
)

function processData() {
  const obj = pool.acquire()
  obj.data = 'some data'
  // 使用对象
  pool.release(obj)
}
```

### 5. 网络优化

#### 请求合并

```javascript
// 批量请求
async function batchRequests(requests) {
  const batched = await Promise.all(
    requests.map(req => fetch(req.url, req.options))
  )
  return batched.map(res => res.json())
}

// 使用
const results = await batchRequests([
  { url: '/api/users', options: {} },
  { url: '/api/posts', options: {} },
  { url: '/api/comments', options: {} },
])
```

#### 请求缓存

```javascript
class RequestCache {
  constructor(ttl = 60000) {
    this.cache = new Map()
    this.ttl = ttl
  }

  async get(url, options = {}) {
    const key = `${url}:${JSON.stringify(options)}`

    if (this.cache.has(key)) {
      const { data, timestamp } = this.cache.get(key)
      if (Date.now() - timestamp < this.ttl) {
        return data
      }
    }

    const response = await fetch(url, options)
    const data = await response.json()
    this.cache.set(key, { data, timestamp: Date.now() })
    return data
  }
}

const cache = new RequestCache()
const data = await cache.get('/api/data')
```

## 性能分析工具

### 1. Chrome DevTools

#### Performance 面板

```javascript
// 使用 Performance API 标记
performance.mark('start-process')

// 执行代码
doSomething()

performance.mark('end-process')
performance.measure('process', 'start-process', 'end-process')

const measures = performance.getEntriesByName('process')
console.log('Process duration:', measures[0].duration)
```

#### Network 面板

```javascript
// 监控资源加载
const observer = new PerformanceObserver((list) => {
  const entries = list.getEntries()
  entries.forEach((entry) => {
    console.log(`${entry.name}: ${entry.duration}ms`)
  })
})
observer.observe({ entryTypes: ['resource'] })
```

### 2. Lighthouse

```javascript
// 使用 Lighthouse API
const lighthouse = require('lighthouse')
const chromeLauncher = require('chrome-launcher')

async function runLighthouse(url) {
  const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] })
  const options = { logLevel: 'info', output: 'html', port: chrome.port }
  const runnerResult = await lighthouse(url, options)
  await chrome.kill()
  return runnerResult
}

runLighthouse('https://example.com')
```

### 3. WebPageTest

```bash
# 使用 WebPageTest API
curl "https://www.webpagetest.org/runtest.php?url=https://example.com&k=YOUR_API_KEY"
```

## 性能优化检查清单

### 加载性能

- [ ] 启用 Gzip/Brotli 压缩
- [ ] 使用 CDN 加速静态资源
- [ ] 实现代码分割和懒加载
- [ ] 优化图片格式和大小
- [ ] 使用预加载和预连接
- [ ] 减少 HTTP 请求次数
- [ ] 启用浏览器缓存

### 渲染性能

- [ ] 避免同步脚本阻塞渲染
- [ ] 使用虚拟滚动处理长列表
- [ ] 优化 CSS 选择器
- [ ] 使用 transform 和 opacity 进行动画
- [ ] 避免强制同步布局
- [ ] 使用 requestAnimationFrame

### 运行时性能

- [ ] 避免内存泄漏
- [ ] 使用防抖和节流
- [ ] 优化事件处理
- [ ] 使用 Web Worker 处理计算密集型任务
- [ ] 避免频繁的 DOM 操作

### 监控和分析

- [ ] 集成性能监控
- [ ] 设置性能预算
- [ ] 定期进行性能审计
- [ ] 监控真实用户数据
- [ ] 建立性能告警机制

## 总结

前端性能监控和优化是一个持续的过程，需要：

1. **建立监控体系**：使用性能 API 和监控工具收集数据
2. **设定性能目标**：根据业务需求设定合理的性能指标
3. **持续优化**：基于监控数据不断优化性能
4. **自动化测试**：集成性能测试到 CI/CD 流程
5. **团队协作**：建立性能优化的最佳实践和规范

通过系统化的性能监控和优化，可以显著提升用户体验，改善业务指标。记住，性能优化是一个迭代的过程，需要持续关注和改进。