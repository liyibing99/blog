# 微前端架构设计与实现

随着前端应用的规模不断扩大，单体前端应用面临着构建速度慢、团队协作困难、技术栈固化等问题。微前端架构作为一种解决这些问题的方案，近年来受到了广泛关注。本文将详细介绍微前端架构的设计理念和实现方案。

## 什么是微前端

### 定义

微前端是一种架构风格，将前端应用分解为多个更小、更简单的块，这些块可以由不同的团队独立开发、测试和部署，最终组合成一个完整的应用。

### 核心理念

1. **技术栈无关**：各个微应用可以使用不同的技术栈
2. **独立开发部署**：每个微应用可以独立开发、测试和部署
3. **运行时组合**：微应用在运行时动态加载和组合
4. **隔离性**：微应用之间保持样式、JavaScript 等的隔离

### 适用场景

- 大型企业级应用，需要多个团队协作开发
- 需要渐进式重构的遗留系统
- 需要支持多技术栈的应用
- 需要独立部署和扩展的模块化应用

## 微前端架构方案

### 1. 基于 iframe 的方案

最简单的微前端实现方式，通过 iframe 嵌入不同的应用。

**优点**：
- 实现简单，天然隔离
- 技术栈完全无关
- 样式和 JavaScript 完全隔离

**缺点**：
- 页面加载性能差
- 通信复杂，需要通过 postMessage
- 用户体验不佳，会有多个滚动条
- SEO 不友好

**示例代码**：

```javascript
// 主应用
class IframeMicroApp {
  constructor(options) {
    this.container = options.container
    this.url = options.url
    this.iframe = null
  }

  mount() {
    this.iframe = document.createElement('iframe')
    this.iframe.src = this.url
    this.iframe.style.width = '100%'
    this.iframe.style.height = '100%'
    this.iframe.style.border = 'none'
    this.container.appendChild(this.iframe)

    // 监听子应用消息
    window.addEventListener('message', this.handleMessage)
  }

  unmount() {
    if (this.iframe) {
      this.container.removeChild(this.iframe)
      window.removeEventListener('message', this.handleMessage)
    }
  }

  handleMessage = (event) => {
    if (event.origin !== new URL(this.url).origin) return

    const { type, data } = event.data

    switch (type) {
      case 'routeChange':
        console.log('子应用路由变化:', data)
        break
      case 'error':
        console.error('子应用错误:', data)
        break
    }
  }

  postMessage(type, data) {
    if (this.iframe) {
      this.iframe.contentWindow.postMessage({ type, data }, this.url)
    }
  }
}

// 使用示例
const microApp = new IframeMicroApp({
  container: document.getElementById('app'),
  url: 'https://microapp.example.com'
})

microApp.mount()
```

### 2. 基于 Web Components 的方案

使用 Web Components 技术实现微前端，每个微应用封装为一个自定义元素。

**优点**：
- 原生支持，无需额外依赖
- 良好的封装性
- 可以与任何框架集成

**缺点**：
- 浏览器兼容性问题
- 开发体验不如现代框架
- 生态系统相对较小

**示例代码**：

```javascript
// 微应用封装为 Web Component
class MicroApp extends HTMLElement {
  constructor() {
    super()
    this.shadow = this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    this.render()
    this.loadStyles()
    this.loadScript()
  }

  async loadStyles() {
    const styleUrl = this.getAttribute('style-url')
    if (styleUrl) {
      const response = await fetch(styleUrl)
      const style = await response.text()
      const styleElement = document.createElement('style')
      styleElement.textContent = style
      this.shadow.appendChild(styleElement)
    }
  }

  async loadScript() {
    const scriptUrl = this.getAttribute('script-url')
    if (scriptUrl) {
      const script = document.createElement('script')
      script.src = scriptUrl
      script.onload = () => {
        this.dispatchEvent(new CustomEvent('loaded'))
      }
      this.shadow.appendChild(script)
    }
  }

  render() {
    const template = this.getAttribute('template')
    if (template) {
      this.shadow.innerHTML = template
    }
  }
}

customElements.define('micro-app', MicroApp)

// 使用示例
<micro-app
  style-url="https://microapp.example.com/styles.css"
  script-url="https://microapp.example.com/app.js"
  template="<div id='root'></div>"
></micro-app>
```

### 3. 基于 qiankun 的方案

qiankun 是基于 single-spa 的微前端实现库，提供了更完善的微前端解决方案。

**优点**：
- 成熟稳定，社区活跃
- 开箱即用，配置简单
- 支持 HTML Entry
- 良好的样式隔离和 JS 沙箱
- 支持预加载

**缺点**：
- 需要学习 qiankun 的 API
- 对子应用有一定要求

**主应用配置**：

```javascript
// main-app/src/micro-app.js
import { registerMicroApps, start } from 'qiankun'

const microApps = [
  {
    name: 'react-app',
    entry: '//localhost:7100',
    container: '#subapp-viewport',
    activeRule: '/react',
    props: {
      routerBase: '/react',
      getGlobalState: () => store.getState()
    }
  },
  {
    name: 'vue-app',
    entry: '//localhost:7200',
    container: '#subapp-viewport',
    activeRule: '/vue',
    props: {
      routerBase: '/vue',
      getGlobalState: () => store.getState()
    }
  }
]

registerMicroApps(microApps, {
  beforeLoad: [
    app => {
      console.log('[主应用] before load', app.name)
    }
  ],
  beforeMount: [
    app => {
      console.log('[主应用] before mount', app.name)
    }
  ],
  afterMount: [
    app => {
      console.log('[主应用] after mount', app.name)
    }
  ],
  afterUnmount: [
    app => {
      console.log('[主应用] after unmount', app.name)
    }
  ]
})

start({
  sandbox: {
    strictStyleIsolation: true,
    experimentalStyleIsolation: true
  },
  prefetch: true,
  singular: false
})
```

**子应用配置（React）**：

```javascript
// react-app/public-path.js
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__
}

// react-app/src/index.js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import './public-path'

let root = null

function render(props) {
  const { container } = props
  const dom = container
    ? container.querySelector('#root')
    : document.querySelector('#root')

  root = ReactDOM.createRoot(dom)
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  )
}

if (!window.__POWERED_BY_QIANKUN__) {
  render({})
}

export async function bootstrap() {
  console.log('[React 子应用] bootstrap')
}

export async function mount(props) {
  console.log('[React 子应用] mount', props)
  render(props)
}

export async function unmount(props) {
  console.log('[React 子应用] unmount')
  if (root) {
    root.unmount()
    root = null
  }
}

export async function update(props) {
  console.log('[React 子应用] update props', props)
}
```

**子应用配置（Vue）**：

```javascript
// vue-app/src/main.js
import Vue from 'vue'
import App from './App.vue'
import router from './router'

let instance = null

function render(props = {}) {
  const { container } = props
  instance = new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount(container ? container.querySelector('#app') : '#app')
}

if (!window.__POWERED_BY_QIANKUN__) {
  render()
}

export async function bootstrap() {
  console.log('[Vue 子应用] bootstrap')
}

export async function mount(props) {
  console.log('[Vue 子应用] mount', props)
  render(props)
}

export async function unmount() {
  console.log('[Vue 子应用] unmount')
  instance.$destroy()
  instance.$el.innerHTML = ''
  instance = null
}

export async function update(props) {
  console.log('[Vue 子应用] update props', props)
}
```

### 4. 基于 Module Federation 的方案

Webpack 5 引入的 Module Federation 是一种更现代化的微前端解决方案。

**优点**：
- Webpack 原生支持，无需额外依赖
- 支持动态加载和共享依赖
- 开发体验好
- 性能优秀

**缺点**：
- 需要 Webpack 5+
- 配置相对复杂

**主应用配置**：

```javascript
// main-app/webpack.config.js
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin')

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'main_app',
      remotes: {
        reactApp: 'react_app@http://localhost:7100/remoteEntry.js',
        vueApp: 'vue_app@http://localhost:7200/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
        vue: { singleton: true }
      }
    })
  ]
}

// main-app/src/App.js
import React, { lazy, Suspense } from 'react'

const ReactApp = lazy(() => import('reactApp/App'))
const VueApp = lazy(() => import('vueApp/App'))

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <ReactApp />
        <VueApp />
      </Suspense>
    </div>
  )
}

export default App
```

**子应用配置（React）**：

```javascript
// react-app/webpack.config.js
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin')

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'react_app',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
}

// react-app/src/App.js
import React from 'react'

function App() {
  return (
    <div>
      <h1>React Micro App</h1>
      <p>This is a React micro application</p>
    </div>
  )
}

export default App
```

## 微前端最佳实践

### 1. 样式隔离

**CSS Modules**：

```javascript
// 使用 CSS Modules
import styles from './App.module.css'

function App() {
  return <div className={styles.container}>Content</div>
}
```

**Shadow DOM**：

```javascript
class MicroApp extends HTMLElement {
  constructor() {
    super()
    this.shadow = this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    const style = document.createElement('style')
    style.textContent = `
      .container {
        padding: 20px;
        background: white;
      }
    `
    this.shadow.appendChild(style)

    const container = document.createElement('div')
    container.className = 'container'
    container.textContent = 'Content'
    this.shadow.appendChild(container)
  }
}
```

**CSS-in-JS**：

```javascript
import styled from 'styled-components'

const Container = styled.div`
  padding: 20px;
  background: white;
`

function App() {
  return <Container>Content</Container>
}
```

### 2. JavaScript 沙箱

**快照沙箱**：

```javascript
class SnapshotSandbox {
  constructor() {
    this.windowSnapshot = {}
    this.modifyPropsMap = {}
  }

  active() {
    this.windowSnapshot = {}
    for (const prop in window) {
      this.windowSnapshot[prop] = window[prop]
    }

    Object.keys(this.modifyPropsMap).forEach(prop => {
      window[prop] = this.modifyPropsMap[prop]
    })
  }

  inactive() {
    for (const prop in window) {
      if (window[prop] !== this.windowSnapshot[prop]) {
        this.modifyPropsMap[prop] = window[prop]
        window[prop] = this.windowSnapshot[prop]
      }
    }
  }
}
```

**代理沙箱**：

```javascript
class ProxySandbox {
  constructor() {
    const fakeWindow = Object.create(null)
    const proxy = new Proxy(fakeWindow, {
      set: (target, prop, value) => {
        target[prop] = value
        return true
      },
      get: (target, prop) => {
        return target[prop] || window[prop]
      }
    })
    this.proxy = proxy
  }
}
```

### 3. 应用间通信

**基于事件总线**：

```javascript
// 事件总线
class EventBus {
  constructor() {
    this.events = {}
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = []
    }
    this.events[event].push(callback)
  }

  off(event, callback) {
    if (!this.events[event]) return
    this.events[event] = this.events[event].filter(cb => cb !== callback)
  }

  emit(event, data) {
    if (!this.events[event]) return
    this.events[event].forEach(callback => callback(data))
  }
}

const eventBus = new EventBus()

// 子应用 A 发送消息
eventBus.emit('user:login', { userId: 123 })

// 子应用 B 监听消息
eventBus.on('user:login', (data) => {
  console.log('User logged in:', data.userId)
})
```

**基于状态管理**：

```javascript
// 全局状态管理
class GlobalStore {
  constructor() {
    this.state = {}
    this.listeners = []
  }

  getState() {
    return this.state
  }

  setState(newState) {
    this.state = { ...this.state, ...newState }
    this.notify()
  }

  subscribe(listener) {
    this.listeners.push(listener)
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener)
    }
  }

  notify() {
    this.listeners.forEach(listener => listener(this.state))
  }
}

const globalStore = new GlobalStore()

// 子应用使用
globalStore.subscribe((state) => {
  console.log('State changed:', state)
})

globalStore.setState({ user: { name: 'John' } })
```

### 4. 路由管理

**统一路由管理**：

```javascript
// 主应用路由
const routes = [
  {
    path: '/',
    component: Home
  },
  {
    path: '/react/*',
    component: ReactMicroApp
  },
  {
    path: '/vue/*',
    component: VueMicroApp
  }
]

// 子应用路由配置
const microRoutes = [
  {
    path: '/dashboard',
    component: Dashboard
  },
  {
    path: '/settings',
    component: Settings
  }
]

// 子应用需要配置 base 路径
const router = createRouter({
  history: createWebHistory('/react'),
  routes: microRoutes
})
```

### 5. 性能优化

**预加载**：

```javascript
// qiankun 预加载配置
start({
  prefetch: 'all' // 或 'true' 或 '[]'
})

// 手动预加载
import { prefetchApps } from 'qiankun'

prefetchApps([
  {
    name: 'react-app',
    entry: '//localhost:7100'
  }
])
```

**懒加载**：

```javascript
// 动态导入
const ReactApp = lazy(() => import('reactApp/App'))

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <ReactApp />
    </Suspense>
  )
}
```

**缓存策略**：

```javascript
// 配置缓存
start({
  prefetch: true,
  sandbox: {
    strictStyleIsolation: true
  },
  singular: false,
  getTemplate: (tpl) => {
    // 可以在这里添加缓存逻辑
    return tpl
  }
})
```

## 微前端架构设计

### 整体架构

```
┌─────────────────────────────────────────┐
│           主应用 (Main App)             │
│  ┌─────────────────────────────────┐   │
│  │   路由管理   │   │
│  ├─────────────────────────────────┤   │
│  │   状态管理   │   │
│  ├─────────────────────────────────┤   │
│  │   微应用加载器   │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
┌───────▼────┐ ┌───▼────┐ ┌───▼────┐
│ 微应用 A   │ │ 微应用 B │ │ 微应用 C │
│ (React)    │ │ (Vue)   │ │ (Angular)│
└────────────┘ └────────┘ └─────────┘
```

### 目录结构

```
micro-frontend-project/
├── main-app/              # 主应用
│   ├── src/
│   │   ├── micro-apps/    # 微应用配置
│   │   ├── router/        # 路由配置
│   │   ├── store/         # 状态管理
│   │   └── components/    # 公共组件
│   └── package.json
├── micro-apps/            # 微应用目录
│   ├── react-app/         # React 微应用
│   ├── vue-app/           # Vue 微应用
│   └── angular-app/       # Angular 微应用
└── shared/                # 共享资源
    ├── components/        # 共享组件
    ├── utils/             # 工具函数
    └── types/             # 类型定义
```

## 总结

微前端架构为大型前端应用提供了一种灵活、可扩展的解决方案。通过合理选择微前端方案和遵循最佳实践，我们可以：

1. 实现技术栈无关，各团队可以自主选择技术栈
2. 提高开发效率，支持独立开发和部署
3. 降低维护成本，实现渐进式重构
4. 提升用户体验，通过预加载和缓存优化性能

在实际项目中，应根据团队规模、技术栈和业务需求选择合适的微前端方案，并持续优化和改进架构设计。
